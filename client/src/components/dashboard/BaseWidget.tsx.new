import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { MoreVertical, GripHorizontal, Pin, Maximize2, Minimize2, MoveHorizontal, LayoutGrid, MoveVertical, Maximize, Layers, Grid2X2, X, ExternalLink } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
} from "@/components/ui/dropdown-menu";
import { motion, AnimatePresence } from "framer-motion";
import { DraggableProvidedDragHandleProps } from "@hello-pangea/dnd";
import { useWidgetStore, type WidgetId, type Size, type WidgetSize } from "@/lib/stores/useWidgetStore";
import { useState, useRef, useEffect, useMemo } from "react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Input } from "@/components/ui/input";

interface BaseWidgetProps {
  widget: {
    id: WidgetId;
    title: string;
    type: string;
    pinned?: boolean;
    size?: Size;
    variant?: string;
    icon?: React.FC<{ className?: string }>;
    badge?: string;
    padding?: string;
    colors?: {
      primary?: string;
      background?: string;
      text?: string;
    };
  };
  onRemove?: () => void;
  children: React.ReactNode;
  dragHandleProps?: DraggableProvidedDragHandleProps;
  isFullscreen?: boolean;
  onFullscreenChange?: (isFullscreen: boolean) => void;
}

// Liste standardisée de toutes les tailles possibles avec leurs dimensions visuelles
const allSizes = [
  { width: 1, height: 1, label: '1×1' },
  { width: 1, height: 2, label: '1×2' },
  { width: 1, height: 3, label: '1×3' },
  { width: 2, height: 1, label: '2×1' },
  { width: 2, height: 2, label: '2×2' },
  { width: 2, height: 3, label: '2×3' },
  { width: 3, height: 1, label: '3×1' },
  { width: 3, height: 2, label: '3×2' },
  { width: 3, height: 3, label: '3×3' }
];

// Définir les tailles compatibles pour chaque type de widget
const compatibleSizes: Record<string, Array<{ width: number, height: number, label: string }>> = {
  // Widget séparateur de section: uniquement en format 3x1
  'section-title': [
    { width: 3, height: 1, label: '3×1' }
  ],
  
  // Par défaut, tous les widgets supportent toutes les tailles
  'default': allSizes,
};

// Fonction pour obtenir les tailles compatibles pour un type de widget
function getAllCompatibleSizes(widgetType: string) {
  if (widgetType === 'section-title') {
    return compatibleSizes['section-title'];
  }
  return allSizes; // Tous les widgets ont accès à toutes les tailles
}

// Types de widgets qui doivent utiliser la configuration par défaut
const defaultWidgetTypes = [
  'stats', 'revenue-chart', 'expense-breakdown', 'occupancy', 
  'tenant-status', 'recent-activity', 'property-comparison',
  'alerts', 'maintenance', 'iot-devices', 'predictive-analytics',
  'property-insights', 'rental-performance', 'visits-calendar',
  'visits-widget', 'performance-analytics', 'cashflow-sankey',
  'portfolio-radar', 'performance-metrics', 'maintenance-costs',
  'property-comparison-table', 'cashflow-sankey-diagram',
  'portfolio-radar-chart', 'flux-financiers', 'flux-financiers-sankey',
  'performance-metrics', 'expense-breakdown', 'revenue-chart',
  'occupancy', 'tenant-status', 'maintenance', 'maintenance-costs',
  'recent-activity', 'alerts', 'iot-devices', 'property-comparison-table',
  'portfolio-radar-chart', 'cashflow-sankey-diagram', 'predictive-analytics',
  'property-insights', 'rental-performance', 'visits-calendar', 'visits-widget'
];

// Plus besoin d'attribuer les tailles car nous utilisons getAllCompatibleSizes
// Suppression de la boucle d'attribution

export function BaseWidget({ 
  widget, 
  onRemove, 
  children, 
  dragHandleProps,
  isFullscreen = false,
  onFullscreenChange
}: BaseWidgetProps) {
  const { updateWidgetSize, togglePinned } = useWidgetStore();
  const [showSizeOptions, setShowSizeOptions] = useState(false);
  const [showOptions, setShowOptions] = useState(false);
  const [settingsOpen, setSettingsOpen] = useState(false);

  // Déterminer les tailles disponibles pour ce type de widget
  const availableSizes = useMemo(() => {
    return getAllCompatibleSizes(widget.type);
  }, [widget.type]);

  // Dimension actuelle pour l'interface utilisateur
  const currentDimension = useMemo(() => {
    const width = widget.size?.width || 1;
    const height = widget.size?.height || 1;
    return `${width}×${height}`;
  }, [widget.size?.width, widget.size?.height]);

  // Fonction pour rendre les options de redimensionnement
  const renderResizeOptions = () => {
    return (
      <div className="grid grid-cols-3 gap-1">
        {availableSizes.map((size, index) => (
          <Button 
            key={index}
            variant="outline" 
            size="sm" 
            className="px-2 py-1 h-auto text-xs"
            onClick={() => handleSizeChange(size.width, size.height)}
          >
            {size.label}
          </Button>
        ))}
      </div>
    );
  };

  // Gestion du changement de taille du widget
  const handleSizeChange = (width: number, height: number) => {
    // Si la taille n'a pas changé, ne rien faire
    if (widget.size?.width === width && widget.size?.height === height) {
      setShowSizeOptions(false);
      return;
    }
    
    console.log(`[BaseWidget] Changing widget size ${widget.id} (${widget.title}) from ${widget.size?.width}x${widget.size?.height} to ${width}x${height}`);
    
    // Effet visuel pour le redimensionnement
    const widgetElement = document.getElementById(`widget-${widget.id}`);
    
    if (!widgetElement) {
      console.error(`Widget element with ID widget-${widget.id} not found. Current widget:`, widget);
      
      // Rechercher tous les éléments de widget pour déboguer
      const allWidgets = document.querySelectorAll('.widget-container');
      console.log('All widget elements:', Array.from(allWidgets).map(el => el.id));
    }
    
    if (widgetElement) {
      // Animation
      widgetElement.classList.add('widget-resizing');
      
      // Mettre à jour les classes CSS immédiatement
      console.log('Before class update:', widgetElement.className);
      
      // Chercher et supprimer les classes existantes de taille
      const oldSizeClass = widgetElement.className.match(/size-\d+x\d+/)?.[0];
      if (oldSizeClass) {
        console.log(`Removing old size class: ${oldSizeClass}`);
        widgetElement.classList.remove(oldSizeClass);
      } else {
        console.log('No existing size class found');
      }
      
      // Ajouter la nouvelle classe de taille
      const newSizeClass = `size-${width}x${height}`;
      console.log(`Adding new size class: ${newSizeClass}`);
      widgetElement.classList.add(newSizeClass);
      
      // Mettre à jour les spans de colonne et ligne
      const oldColSpanClass = widgetElement.className.match(/col-span-\d+/)?.[0];
      const oldRowSpanClass = widgetElement.className.match(/row-span-\d+/)?.[0];
      
      if (oldColSpanClass) {
        console.log(`Removing old column span: ${oldColSpanClass}`);
        widgetElement.classList.remove(oldColSpanClass);
      }
      
      if (oldRowSpanClass) {
        console.log(`Removing old row span: ${oldRowSpanClass}`);
        widgetElement.classList.remove(oldRowSpanClass);
      }
      
      // Ajouter les nouvelles classes de span
      const newColSpanClass = `col-span-${width}`;
      const newRowSpanClass = `row-span-${height}`;
      
      console.log(`Adding column span: ${newColSpanClass}`);
      widgetElement.classList.add(newColSpanClass);
      
      console.log(`Adding row span: ${newRowSpanClass}`);
      widgetElement.classList.add(newRowSpanClass);
      
      console.log('After class update:', widgetElement.className);
      
      // Mettre également à jour les attributs data
      widgetElement.setAttribute('data-size', `${width}x${height}`);
      widgetElement.setAttribute('data-width', width.toString());
      widgetElement.setAttribute('data-height', height.toString());
      
      // Ajouter l'indicateur visuel de taille
      const sizeIndicator = document.createElement('div');
      sizeIndicator.className = 'size-indicator';
      sizeIndicator.textContent = `${width}×${height}`;
      widgetElement.appendChild(sizeIndicator);
      
      // Nettoyer après l'animation
      setTimeout(() => {
        widgetElement.classList.remove('widget-resizing');
        const indicator = widgetElement.querySelector('.size-indicator');
        if (indicator) indicator.remove();
      }, 600);
    }
    
    // Mettre à jour la taille dans le store
    updateWidgetSize(widget.id, { width, height });
    
    // Forcer un redimensionnement de la fenêtre et déclencher un événement custom
    setTimeout(() => {
      // Déclencher un événement personnalisé pour informer le layout du changement
      window.dispatchEvent(new CustomEvent('widget-size-changed', { 
        detail: { 
          widgetId: widget.id, 
          oldSize: widget.size, 
          newSize: { width, height } 
        }
      }));
      
      console.log('[BaseWidget] Dispatched widget-size-changed event');
      
      // Forcer un redimensionnement de la fenêtre pour adapter la grille
      window.dispatchEvent(new Event('resize'));
      
      console.log('[BaseWidget] Dispatched resize event');
    }, 50);
    
    // Fermer le menu
    setShowSizeOptions(false);
  };

  // Gestion de l'épinglage
  const handleTogglePin = () => {
    togglePinned(widget.id);
  };

  // Gestion du plein écran
  const handleToggleFullscreen = () => {
    const newState = !isFullscreen;
    onFullscreenChange?.(newState);
  };
  
  // Gestion de la suppression du widget
  const handleRemove = () => {
    setShowOptions(false);
    onRemove?.();
  };

  return (
    <motion.div
      id={`widget-${widget.id}`}
      layout
      initial={{ opacity: 0.9, scale: 0.98 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.2 }}
      className={cn(
        "widget-card",
        widget.pinned && "pinned",
        isFullscreen && "fullscreen"
      )}
      style={{
        ...(widget.colors && {
          borderColor: widget.colors.primary,
          backgroundColor: widget.colors.background,
          color: widget.colors.text
        })
      }}
    >
      {/* En-tête du widget */}
      <div className="widget-card-header">
        <div className="flex items-center gap-2 overflow-hidden">
          {widget.icon && <widget.icon className="h-4 w-4 text-muted-foreground flex-shrink-0" />}
          
          <h3 className="widget-card-title">
            {widget.title}
          </h3>
          
          {widget.badge && (
            <Badge variant="outline" className="ml-auto text-[0.65rem] px-1 h-5">
              {widget.badge}
            </Badge>
          )}
          
          {/* Indicateur de dimensions actuelles */}
          <Badge variant="secondary" className="ml-auto h-4 px-1 text-[0.6rem]">
            {currentDimension}
          </Badge>
        </div>
        
        {/* Contrôles du widget */}
        <div className="widget-controls">
          {/* Bouton d'épinglage */}
          <button
            className={cn("widget-control-button", widget.pinned && "active")}
            onClick={handleTogglePin}
            title={widget.pinned ? "Désépingler" : "Épingler"}
          >
            <Pin className={cn("h-3.5 w-3.5", widget.pinned && "fill-current")} />
          </button>
          
          {/* Menu de redimensionnement */}
          <Popover open={showSizeOptions} onOpenChange={setShowSizeOptions}>
            <PopoverTrigger asChild>
              <button 
                className="widget-control-button"
                title="Redimensionner"
              >
                <Grid2X2 className="h-3.5 w-3.5" />
              </button>
            </PopoverTrigger>
            <PopoverContent className="p-2 w-auto" align="end">
              {renderResizeOptions()}
            </PopoverContent>
          </Popover>
          
          {/* Bouton plein écran */}
          <button
            className="widget-control-button"
            onClick={handleToggleFullscreen}
            title={isFullscreen ? "Quitter le plein écran" : "Plein écran"}
          >
            {isFullscreen ? (
              <Minimize2 className="h-3.5 w-3.5" />
            ) : (
              <Maximize2 className="h-3.5 w-3.5" />
            )}
          </button>
          
          {/* Menu d'options */}
          <DropdownMenu open={showOptions} onOpenChange={setShowOptions}>
            <DropdownMenuTrigger asChild>
              <button className="widget-control-button">
                <MoreVertical className="h-3.5 w-3.5" />
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="min-w-[160px]">
              <DropdownMenuLabel className="text-xs">Options</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={handleRemove} className="text-destructive">
                <X className="mr-2 h-4 w-4" />
                Supprimer
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
      
      {/* Poignée de déplacement */}
      {dragHandleProps && (
        <div 
          {...dragHandleProps} 
          className="absolute -top-3 left-1/2 -translate-x-1/2 w-7 h-7 bg-background border border-border rounded-full grid place-items-center cursor-grab opacity-0 group-hover:opacity-90 transition-opacity"
        >
          <GripHorizontal className="h-3.5 w-3.5 text-muted-foreground" />
        </div>
      )}
      
      {/* Contenu du widget */}
      <div className={cn(
        "widget-card-content",
        widget.padding,
        isFullscreen && "max-h-[calc(100vh-var(--grid-widget-header))]"
      )}>
        {children}
      </div>
    </motion.div>
  );
}
