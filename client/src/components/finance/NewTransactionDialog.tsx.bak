import { useEffect, useState } from "react";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { insertTransactionSchema, type Transaction } from "../../../../shared/schema";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue, SelectSeparator, SelectLabel, SelectGroup } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { z } from 'zod';
import { format, parseISO } from 'date-fns';
import { PDFUpload } from "@/components/ui/pdf-upload";
import { fr } from 'date-fns/locale';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { apiRequest } from "@/lib/queryClient";
import { AlertCircle, Euro, Calendar, HelpCircle, FileText as FileTextIcon, Building2, CreditCard, Clock, ArrowUpCircle, ArrowDownCircle, CreditCardIcon, Tag, Folder, Plus, PlusCircle, Loader2, Pencil as PencilIcon, X, ChevronLeft, ChevronRight, File as FileIcon, FilePenLine, FileSpreadsheet, FileImage, FileCheck, FileSignature, Mail, Camera, Clipboard, FileSearch } from "lucide-react";
import { motion } from "framer-motion";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Combobox } from "@/components/ui/combobox";
import { Label } from "@/components/ui/label";

interface ExtendedTransaction extends Omit<Transaction, 'documentIds'> {
  documentId: number | null;
  documentIds: number[] | null;
  folderId?: number | null;
}

const transactionFormSchema = insertTransactionSchema.omit({ userId: true }).extend({
  amount: z.coerce.number(),
  date: z.string(),
  documents: z.object({
    files: z.array(z.instanceof(File)),
    folderId: z.number().nullable()
  }).optional()
});

type TransactionFormData = z.infer<typeof transactionFormSchema>;

interface DocumentWithType {
  file: File;
  type: string;
}

interface Props {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  editingTransaction?: ExtendedTransaction;
}

interface Property {
  id: number;
  name: string;
}

interface Folder {
  id: number;
  name: string;
  path: string;
}

interface DocumentTypeConfig {
  [key: string]: {
    label: string;
    icon: JSX.Element;
  };
}

export function NewTransactionDialog({ open, onOpenChange, editingTransaction }: Props) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [transactions, setTransactions] = useState<TransactionFormData[]>([{
    type: "income",
    propertyId: null as unknown as number,
    tenantId: null,
    category: "rent",
    amount: 0,
    description: "",
    date: format(new Date(), 'yyyy-MM-dd'),
    paymentMethod: "bank_transfer",
    status: "pending",
    documents: {
      files: [],
      folderId: null
    }
  }]);
  const [currentTransactionIndex, setCurrentTransactionIndex] = useState(0);
  const [documentId, setDocumentId] = useState<number | null>(null);
  const [documentIds, setDocumentIds] = useState<number[]>([]);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [selectedFolderId, setSelectedFolderId] = useState<number | null>(null);
  const [showCreateFolder, setShowCreateFolder] = useState(false);
  const [isCreatingFolder, setIsCreatingFolder] = useState(false);
  const [newFolderName, setNewFolderName] = useState("");
  const [key, setKey] = useState(0);
  const [previewDocument, setPreviewDocument] = useState<number | null>(null); 
  const [documentTypes, setDocumentTypes] = useState<Map<File, string>>(new Map());
  const [documentNames, setDocumentNames] = useState<Map<File, string>>(new Map());
  const [editingDocumentName, setEditingDocumentName] = useState<File | null>(null);
  const [isLoadingDocuments, setIsLoadingDocuments] = useState(false);
  const [existingDocumentIds, setExistingDocumentIds] = useState<number[]>([]);

  const { data: properties = [] } = useQuery<Property[]>({
    queryKey: ["/api/properties"],
  });

  const { data: folders = [] } = useQuery<Folder[]>({
    queryKey: ["/api/folders"],
  });

  const form = useForm<TransactionFormData>({
    resolver: zodResolver(transactionFormSchema),
    defaultValues: {
      type: editingTransaction?.type || "income",
      propertyId: editingTransaction?.propertyId || (null as unknown as number),
      tenantId: editingTransaction?.tenantId || null,
      category: (editingTransaction?.category as "rent" | "maintenance" | "insurance" | "tax" | "utility" | "other") || "rent",
      amount: editingTransaction ? Number(editingTransaction.amount) : 0,
      description: editingTransaction?.description || "",
      date: editingTransaction?.date
        ? format(new Date(editingTransaction.date), 'yyyy-MM-dd')
        : format(new Date(), 'yyyy-MM-dd'),
      paymentMethod: editingTransaction?.paymentMethod || "bank_transfer",
      status: (editingTransaction?.status as "pending" | "completed" | "cancelled" | "failed" | "deleted" | "archived") || "pending",
    }
  });

  useEffect(() => {
    if (editingTransaction) {
      form.reset({
        type: editingTransaction.type,
        propertyId: editingTransaction.propertyId,
        tenantId: editingTransaction.tenantId,
        category: editingTransaction.category as "rent" | "maintenance" | "insurance" | "tax" | "utility" | "other",
        amount: Number(editingTransaction.amount),
        description: editingTransaction.description || "",
        date: format(new Date(editingTransaction.date), 'yyyy-MM-dd'),
        paymentMethod: editingTransaction.paymentMethod || "bank_transfer",
        status: editingTransaction.status as "pending" | "completed" | "cancelled" | "failed" | "deleted" | "archived",
      });
      
      // Gestion du document unique
      setDocumentId(editingTransaction.documentId || null);
      setPreviewDocument(editingTransaction.documentId);
      
      // Gestion des documents multiples
      if (editingTransaction.documentIds && editingTransaction.documentIds.length > 0) {
        console.log(`Chargement de ${editingTransaction.documentIds.length} documents depuis la transaction`);
        setDocumentIds(editingTransaction.documentIds);
        
        // Si plusieurs documents, nous utilisons le premier pour la prévisualisation
        if (!editingTransaction.documentId && editingTransaction.documentIds.length > 0) {
          setPreviewDocument(editingTransaction.documentIds[0]);
        }
        
        // Charger les documents existants pour les afficher dans l'interface
        loadExistingDocuments();
      }
    }
  }, [editingTransaction, form]);

  useEffect(() => {
    if (!open) {
      // Nettoyer tous les états liés aux documents
      setDocumentId(null);
      setDocumentIds([]);
      setSelectedFile(null);
      setSelectedFiles([]);
      setSelectedFolderId(null);
      setIsCreatingFolder(false);
      setNewFolderName("");
      setKey(key + 1);
      setPreviewDocument(null); 
      setDocumentTypes(new Map());
      setDocumentNames(new Map());
      setEditingDocumentName(null);
      setExistingDocumentIds([]);
    }
  }, [open, key]);

  useEffect(() => {
    if (currentTransactionIndex < transactions.length) {
      const currentTransaction = transactions[currentTransactionIndex];
      form.reset({
        type: currentTransaction.type,
        propertyId: currentTransaction.propertyId,
        tenantId: currentTransaction.tenantId,
        category: currentTransaction.category,
        amount: currentTransaction.amount,
        description: currentTransaction.description,
        date: currentTransaction.date,
        paymentMethod: currentTransaction.paymentMethod,
        status: currentTransaction.status,
      });
    }
  }, [currentTransactionIndex, transactions, form]);

  const onFormChange = (data: Partial<TransactionFormData>) => {
    updateTransactionForm(currentTransactionIndex, data);
  };

  const uploadDocument = async () => {
    if (!selectedFile) return null;

    const formData = new FormData();
    formData.append('file', selectedFile);
    
    // Récupérer le type du document s'il existe, sinon utiliser "invoice" par défaut
    const docType = documentTypes.get(selectedFile) || "invoice";
    console.log(`Document type for file ${selectedFile.name}:`, docType);
    formData.append('type', docType);
    
    // Ajouter le titre (nom personnalisé ou nom du fichier par défaut)
    const customName = documentNames.get(selectedFile);
    formData.append('title', customName || selectedFile.name);
    console.log(`Custom name for file ${selectedFile.name}:`, customName || 'not set');
    
    // Ajouter l'ID du dossier si disponible
    if (selectedFolderId) {
      formData.append('folderId', selectedFolderId.toString());
    }

    const currentData = form.getValues();
    const isMaintenance = currentData.category === 'maintenance';
    const documentCategory = isMaintenance ? 'maintenance' : 'finance';
    const documentDescription = isMaintenance 
      ? `Document de maintenance associé à une transaction de ${currentData.amount}€`
      : `Document financier associé à une transaction de ${currentData.amount}€`;

    // Récupérer le libellé du type de document pour l'affichage
    const docTypeLabel = documentTypeConfig[docType as keyof DocumentTypeConfig]?.label || "Factures";
    console.log(`Document type label for file ${selectedFile.name}:`, docTypeLabel);

    // Ajouter des métadonnées spécifiques pour la section finance
    const formDataObj = {
      section: 'finance',
      description: documentDescription,
      source: 'finance_form',
      transactionType: currentData.type,
      documentTypeLabel: docTypeLabel,
      uploadSource: 'finance_form',
      uploadMethod: 'form',
      uploadContext: 'transaction',
      documentCategory: documentCategory,
      originalFileName: selectedFile.name,
      customFileName: customName || selectedFile.name
    };
    console.log(`FormData for file ${selectedFile.name}:`, formDataObj);
    formData.append('formData', JSON.stringify(formDataObj));

    try {
      const response = await fetch('/api/documents', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) throw new Error("Erreur lors du téléchargement du document");

      const data = await response.json();
      console.log(`Upload response for file ${selectedFile.name}:`, data);
      return data.id;
    } catch (error) {
      console.error('Error uploading document:', error);
      toast({
        variant: "destructive",
        title: "Erreur",
        description: "Impossible de télécharger le document"
      });
      throw error;
    }
  };
  
  // Nouvelle fonction pour télécharger plusieurs documents
  const uploadMultipleDocuments = async () => {
    try {
    if (!selectedFiles || selectedFiles.length === 0) return [];

      console.log(`Uploading ${selectedFiles.length} documents...`);
      
      // Préparer l'objet qui contient les noms personnalisés des fichiers
      const customNamesObj: Record<string, string> = {};
      selectedFiles.forEach(file => {
        const customName = documentNames.get(file);
        if (customName) {
          customNamesObj[file.name] = customName;
        }
      });
      
      // Convertir l'objet en JSON s'il y a des noms personnalisés
      const customNamesJson = Object.keys(customNamesObj).length > 0 
        ? JSON.stringify(customNamesObj) 
        : null;
      
      console.log('Custom names for files:', customNamesObj);

      const uploadPromises = selectedFiles.map(async (file) => {
        const formData = new FormData();
        formData.append('file', file);
        
        // Récupérer le type du document s'il existe, sinon utiliser "invoice" par défaut
        const docType = documentTypes.get(file) || "invoice";
        console.log(`Document type for file ${file.name}:`, docType);
        
        // Utiliser le type tel quel sans conversion
        formData.append('type', docType);
        
        // Ajouter le titre (nom personnalisé ou nom du fichier par défaut)
        const customName = documentNames.get(file);
        formData.append('title', customName || file.name);
        
        // Ajouter l'ID du dossier si disponible
        if (selectedFolderId) {
          formData.append('folderId', selectedFolderId.toString());
        }

        const currentData = form.getValues();
        const isMaintenance = currentData.category === 'maintenance';
        const documentCategory = isMaintenance ? 'maintenance' : 'finance';
        const documentDescription = isMaintenance 
          ? `Document de maintenance associé à une transaction de ${currentData.amount}€`
          : `Document financier associé à une transaction de ${currentData.amount}€`;

        // Récupérer le libellé du type de document pour l'affichage
        const docTypeLabel = documentTypeConfig[docType]?.label || "Factures";
        console.log(`Document type label for file ${file.name}:`, docTypeLabel);

        // Ajouter des métadonnées spécifiques pour la section finance
        const formDataObj = {
          section: 'finance',
          description: documentDescription,
          source: 'finance_form',
          transactionType: currentData.type,
          documentTypeLabel: docTypeLabel,
          uploadSource: 'finance_form',
          uploadMethod: 'form',
          uploadContext: 'transaction',
          documentCategory: documentCategory,
          originalFileName: file.name,
          customFileName: customName || file.name
        };
        console.log(`FormData for file ${file.name}:`, formDataObj);
        formData.append('formData', JSON.stringify(formDataObj));

        const response = await fetch('/api/documents', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) throw new Error(`Erreur lors du téléchargement de ${file.name}`);

        const data = await response.json();
        return data.id;
      });

      // Exécute toutes les promesses en parallèle
      const documentIds = await Promise.all(uploadPromises);
      console.log(`Uploaded ${documentIds.length} documents`, documentIds);
      return documentIds;
    } catch (error) {
      console.error('Error uploading multiple documents:', error);
      toast({
        variant: "destructive",
        title: "Erreur",
        description: "Impossible de télécharger certains documents"
      });
      throw error;
    }
  };

  const createTransaction = useMutation({
    mutationFn: async (data: TransactionFormData) => {
      let docId = documentId;
      let docIds: number[] = [];

      // Priorité au mode multiple
      if (selectedFiles && selectedFiles.length > 0) {
        try {
          docIds = await uploadMultipleDocuments();
          console.log("Multiple documents uploaded:", docIds);
        } catch (error) {
          console.error("Error uploading multiple documents:", error);
          throw error;
        }
      } 
      // Fallback au mode unique si aucun fichier multiple n'est sélectionné
      else if (selectedFile) {
        try {
          docId = await uploadDocument();
          console.log("Single document uploaded:", docId);
    } catch (error) {
          console.error("Error uploading single document:", error);
      throw error;
    }
      }

      const transformedData = {
        ...data,
        amount: parseFloat(data.amount.toString()),
        date: parseISO(data.date),
        documentId: docId,
            documentIds: docIds.length > 0 ? docIds : undefined,
          };

          return apiRequest("/api/transactions", {
            method: "POST",
        body: JSON.stringify(transformedData),
          });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/transactions"] });
      queryClient.invalidateQueries({ queryKey: ["/api/documents"] });
      toast({
        title: "Succès",
        description: "Transaction créée avec succès"
      });
      onOpenChange(false);
      form.reset();
      setDocumentId(null);
      setDocumentIds([]);
      setSelectedFile(null);
      setSelectedFiles([]);
      setSelectedFolderId(null);
      setPreviewDocument(null); 
    },
    onError: (error: Error) => {
      console.error("Erreur lors de la création:", error);
      toast({
        title: "Erreur",
        description: error.message || "Impossible de créer la transaction",
        variant: "destructive",
      });
    }
  });

  const loadExistingDocuments = async () => {
    if (!editingTransaction || !editingTransaction.documentIds || editingTransaction.documentIds.length === 0) {
      return;
    }
    
    try {
      // Marquer que le chargement est en cours
      setIsLoadingDocuments(true);
      
      // Récupérer les détails de chaque document
      const documentPromises = editingTransaction.documentIds.map(docId => 
        fetch(`/api/documents/${docId}`).then(res => res.json())
      );
      
      const documents = await Promise.all(documentPromises);
      console.log("Documents existants chargés:", documents);
      
      // Pour chaque document, créer un objet File simulé pour l'interface
      const documentFiles: File[] = [];
      const documentTypesMap = new Map(documentTypes);
      const documentNamesMap = new Map(documentNames);
      
      // Stocker les IDs des documents existants pour les transmettre lors de la mise à jour
      setExistingDocumentIds(editingTransaction.documentIds);
      
      for (const doc of documents) {
        if (!doc.fileExists) continue;
        
        // Créer un objet qui simule un File pour l'interface
        const mockFile = new File(
          [new Blob([''], { type: 'application/pdf' })], 
          doc.originalName, 
          { type: 'application/pdf' }
        );
        
        // Ajouter une propriété personnalisée pour identifier le document existant
        Object.defineProperty(mockFile, 'documentId', {
          value: doc.id,
          writable: false
        });
        
        // Stocker le fichier
        documentFiles.push(mockFile);
        
        // Stocker le type et le nom du document
        documentTypesMap.set(mockFile, doc.type || 'invoice');
        documentNamesMap.set(mockFile, doc.title || doc.originalName);
      }
      
      // Mettre à jour les états
      setDocumentTypes(documentTypesMap);
      setDocumentNames(documentNamesMap);
      
      // Mettre à jour la transaction actuelle avec les fichiers chargés
      if (documentFiles.length > 0) {
        updateTransactionForm(currentTransactionIndex, {
          documents: {
            files: documentFiles,
            folderId: editingTransaction.folderId || null
          }
        });
      }
      
      console.log(`Chargé ${documentFiles.length} documents existants`);
        } catch (error) {
      console.error("Erreur lors du chargement des documents:", error);
          toast({
            variant: "destructive",
            title: "Erreur",
        description: "Impossible de charger les documents existants"
      });
    } finally {
      setIsLoadingDocuments(false);
    }
  };

  const updateTransaction = useMutation({
    mutationFn: async (data: TransactionFormData) => {
      if (!editingTransaction?.id) {
        throw new Error("ID de transaction manquant");
      }

      let docIds: number[] = [];
      
      // 1. Conserver les IDs des documents existants qui n'ont pas été supprimés
      if (existingDocumentIds.length > 0) {
        const currentFiles = transactions[currentTransactionIndex].documents?.files || [];
        const existingFiles = currentFiles.filter(file => 'documentId' in file);
        
        // Récupérer les IDs des documents existants qui sont encore dans la liste
        const retainedDocIds = existingFiles.map(file => (file as any).documentId);
        
        if (retainedDocIds.length > 0) {
          console.log("Documents existants conservés:", retainedDocIds);
          docIds = [...retainedDocIds];
        }
      }
      
      // 2. Ajouter les nouveaux documents
      if (transactions[currentTransactionIndex].documents?.files) {
        const currentFiles = transactions[currentTransactionIndex].documents.files;
        // Filtrer seulement les nouveaux fichiers (ceux qui n'ont pas de documentId)
        const newFiles = currentFiles.filter(file => !('documentId' in file));
        
        if (newFiles.length > 0) {
          console.log(`Téléchargement de ${newFiles.length} nouveaux documents...`);
          
          // Préparer l'objet qui contient les noms personnalisés des fichiers
          const customNamesObj: Record<string, string> = {};
          newFiles.forEach(file => {
            const customName = documentNames.get(file);
            if (customName) {
              customNamesObj[file.name] = customName;
            }
          });
          
          // Convertir l'objet en JSON s'il y a des noms personnalisés
          const customNamesJson = Object.keys(customNamesObj).length > 0 
            ? JSON.stringify(customNamesObj) 
            : null;
          
          console.log('Noms personnalisés pour les fichiers:', customNamesObj);
          
          const uploadPromises = newFiles.map(async (file) => {
            const formData = new FormData();
            formData.append('file', file);
            
            // Récupérer le type du document s'il existe, sinon utiliser "invoice" par défaut
            const docType = documentTypes.get(file) || "invoice";
            console.log(`Type de document pour ${file.name}:`, docType);
            formData.append('type', docType);
            
            // Ajouter le titre (nom personnalisé ou nom du fichier par défaut)
            const customName = documentNames.get(file);
            formData.append('title', customName || file.name);
            console.log(`Nom personnalisé pour ${file.name}:`, customName || 'non défini');
            
            // Ajouter l'ID du dossier si disponible
            if (transactions[currentTransactionIndex].documents?.folderId) {
              formData.append('folderId', transactions[currentTransactionIndex].documents.folderId.toString());
            }
            
            const isMaintenance = data.category === 'maintenance';
            const documentCategory = isMaintenance ? 'maintenance' : 'finance';
            const documentDescription = isMaintenance 
              ? `Document de maintenance associé à une transaction de ${data.amount}€`
              : `Document financier associé à une transaction de ${data.amount}€`;
              
            // Récupérer le libellé du type de document pour l'affichage
            const docTypeLabel = documentTypeConfig[docType as keyof DocumentTypeConfig]?.label || "Factures";
            
            // Ajouter des métadonnées spécifiques pour la section finance
            const formDataObj = {
              section: 'finance',
              description: documentDescription,
              source: 'finance_form',
              transactionType: data.type,
              documentTypeLabel: docTypeLabel,
              uploadSource: 'finance_form',
              uploadMethod: 'form',
              uploadContext: 'transaction',
              documentCategory: documentCategory,
              originalFileName: file.name,
              customFileName: customName || file.name,
              transactionId: editingTransaction.id
            };
            console.log(`Métadonnées pour ${file.name}:`, formDataObj);
            formData.append('formData', JSON.stringify(formDataObj));
            
            const response = await fetch('/api/documents', {
              method: 'POST',
              body: formData,
            });
            
            if (!response.ok) throw new Error(`Erreur lors du téléchargement de ${file.name}`);
            
            const result = await response.json();
            console.log(`Réponse du serveur pour ${file.name}:`, result);
            return result.id;
          });
          
          // Attendre que tous les documents soient téléchargés
          const newDocIds = await Promise.all(uploadPromises);
          console.log("Nouveaux documents téléchargés:", newDocIds);
          
          // Ajouter les nouveaux IDs à la liste complète
          docIds = [...docIds, ...newDocIds];
        }
      }
      
      // Maintenant docIds contient à la fois les documents existants conservés et les nouveaux
      console.log("Liste finale des documents:", docIds);

      const transformedData = {
        ...data,
        amount: parseFloat(data.amount.toString()),
        date: parseISO(data.date),
        documentId: docIds.length > 0 ? docIds[0] : null,
        documentIds: docIds.length > 0 ? docIds : [],
      };

      return apiRequest(`/api/transactions/${editingTransaction.id}`, {
        method: "PUT",
        body: JSON.stringify(transformedData),
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/transactions"] });
      queryClient.invalidateQueries({ queryKey: ["/api/documents"] });
      toast({
        title: "Succès",
        description: "Transaction modifiée avec succès"
      });
      onOpenChange(false);
      setDocumentId(null);
      setDocumentIds([]);
      setSelectedFile(null);
      setSelectedFiles([]);
      setExistingDocumentIds([]);
      setPreviewDocument(null); 
    },
    onError: (error: Error) => {
      console.error("Erreur lors de la modification:", error);
      toast({
        title: "Erreur",
        description: error.message || "Impossible de modifier la transaction",
        variant: "destructive",
      });
    }
  });

  const addNewTransaction = () => {
    setTransactions(prev => [...prev, {
      type: "income",
      propertyId: null as unknown as number,
      tenantId: null,
      category: "rent",
      amount: 0,
      description: "",
      date: format(new Date(), 'yyyy-MM-dd'),
      paymentMethod: "bank_transfer",
      status: "pending",
      documents: {
        files: [],
        folderId: null
      }
    }]);
    const newIndex = transactions.length;
    setCurrentTransactionIndex(newIndex);
    setKey(key => key + 1);
  };

  const removeTransaction = (index: number) => {
    if (transactions.length > 1) {
      setTransactions(prev => prev.filter((_, i) => i !== index));
      setCurrentTransactionIndex(prev => Math.min(prev, transactions.length - 2));
    }
  };

  const updateTransactionForm = (index: number, data: Partial<TransactionFormData>) => {
    setTransactions(prev => prev.map((t, i) => {
      if (i === index) {
        const updatedTransaction = {
          ...t,
          ...data,
          // Préserver les documents existants si non explicitement fournis dans data
          documents: data.documents 
            ? {
                // Si files est fourni, l'utiliser, sinon conserver l'existant
                files: data.documents.files || t.documents?.files || [],
                // Si folderId est fourni, l'utiliser, sinon conserver l'existant
                folderId: data.documents.folderId !== undefined 
                  ? data.documents.folderId 
                  : t.documents?.folderId || null
              }
            : t.documents || { files: [], folderId: null }
        };
        
        // Log pour déboguer
        console.log(`Mise à jour de la transaction ${index + 1}`);
        console.log(`Nombre de documents après mise à jour: ${updatedTransaction.documents?.files?.length || 0}`);
        
        return updatedTransaction;
      }
      return t;
    }));
  };

  const handleFileSelected = (files: File | File[]) => {
    const fileArray = Array.isArray(files) ? files : [files];
    const currentTransaction = transactions[currentTransactionIndex];
    const existingFiles = currentTransaction.documents?.files || [];
    
    // Fusionner les fichiers existants avec les nouveaux fichiers
    // Utiliser Set pour éviter les doublons basés sur le nom de fichier
    const fileSet = new Set([...existingFiles, ...fileArray].map(file => file.name));
    const uniqueFiles = [...existingFiles];
    
    // Ajouter seulement les nouveaux fichiers
    fileArray.forEach(file => {
      if (!existingFiles.some(existing => existing.name === file.name)) {
        uniqueFiles.push(file);
      }
    });
    
    console.log(`Fichiers sélectionnés: ${fileArray.length}`);
    console.log(`Fichiers existants: ${existingFiles.length}`);
    console.log(`Fichiers totaux après fusion: ${uniqueFiles.length}`);
    
    // Conserver le dossier sélectionné actuel
    const currentFolderId = currentTransaction.documents?.folderId || selectedFolderId;
    
    updateTransactionForm(currentTransactionIndex, {
      documents: {
        files: uniqueFiles,
        folderId: currentFolderId
      }
    });
  };

  const onSubmit = async () => {
    try {
      for (const transaction of transactions) {
        let docIds: number[] = [];
        
        // Upload documents if any
        if (transaction.documents?.files?.length) {
          const files = transaction.documents.files;
          
          // Préparer l'objet qui contient les noms personnalisés des fichiers
          const customNamesObj: Record<string, string> = {};
          files.forEach(file => {
            const customName = documentNames.get(file);
            if (customName) {
              customNamesObj[file.name] = customName;
            }
          });
          
          // Convertir l'objet en JSON s'il y a des noms personnalisés
          const customNamesJson = Object.keys(customNamesObj).length > 0 
            ? JSON.stringify(customNamesObj) 
            : null;
          
          console.log('Custom names for files:', customNamesObj);
          
          const uploadPromises = files.map(async (file, index) => {
            const formData = new FormData();
            
            // Ajouter le fichier
            formData.append('file', file);
            
            // Récupérer le type du document s'il existe, sinon utiliser "invoice" par défaut
            const docType = documentTypes.get(file) || "invoice";
            console.log(`Document type for file ${file.name}:`, docType);
            
            // Utiliser le type tel quel sans conversion
            formData.append('type', docType);
            
            // Ajouter le titre (nom personnalisé ou nom du fichier par défaut)
            const customName = documentNames.get(file);
            formData.append('title', customName || file.name);
            
            // Ajouter l'ID du dossier si disponible
            if (transaction.documents?.folderId) {
              formData.append('folderId', transaction.documents.folderId.toString());
            }

            // Récupérer le libellé du type de document pour l'affichage
            const docTypeLabel = documentTypeConfig[docType as keyof DocumentTypeConfig]?.label || "Factures";
            console.log(`Document type label for file ${file.name}:`, docTypeLabel);

            // Déterminer la catégorie du document et sa description
            const isMaintenance = transaction.category === 'maintenance';
            const documentCategory = isMaintenance ? 'maintenance' : 'finance';
            const documentDescription = isMaintenance 
              ? `Document de maintenance associé à une transaction de ${transaction.amount}€`
              : `Document financier associé à une transaction de ${transaction.amount}€`;

            // Ajouter des métadonnées spécifiques pour la section finance
            const formDataObj = {
              section: 'finance',
              description: documentDescription,
              source: 'finance_form',
              transactionType: transaction.type,
              documentTypeLabel: docTypeLabel,
              uploadSource: 'finance_form',
              uploadMethod: 'form',
              uploadContext: 'transaction',
              documentCategory: documentCategory,
              originalFileName: file.name,
              customFileName: customName || file.name
            };
            console.log(`FormData for file ${file.name}:`, formDataObj);
            formData.append('formData', JSON.stringify(formDataObj));

            // Utiliser l'endpoint standard /api/documents pour l'upload
            const response = await fetch('/api/documents', {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              throw new Error(`Erreur lors du téléchargement du document ${file.name}`);
            }
            
            const data = await response.json();
            console.log(`Upload response for file ${file.name}:`, data);
            return data.id;
          });
          
          // Attendre que tous les documents soient uploadés
          docIds = await Promise.all(uploadPromises);
          console.log(`All document IDs for transaction:`, docIds);
        }

        // Create transaction with document IDs
        await createTransaction.mutateAsync({
          ...transaction,
          documents: undefined,
          documentIds: docIds
        });
      }

      toast({
        title: "Succès",
        description: `${transactions.length} transaction(s) créée(s) avec succès`
      });
      onOpenChange(false);
      setTransactions([{
        type: "income",
        propertyId: null as unknown as number,
        tenantId: null,
        category: "rent",
        amount: 0,
        description: "",
        date: format(new Date(), 'yyyy-MM-dd'),
        paymentMethod: "bank_transfer",
        status: "pending",
        documents: {
          files: [],
          folderId: null
        }
      }]);
      setCurrentTransactionIndex(0);
      setDocumentTypes(new Map()); // Réinitialiser la carte des types de documents
    } catch (error: any) {
      toast({
        title: "Erreur de validation",
        description: error.message || "Veuillez vérifier les champs du formulaire",
        variant: "destructive",
      });
    }
  };

  const formatPropertiesForSelect = (properties: Property[] = []) => {
    return properties.map(property => ({
      value: property.id.toString(),
      label: `${property.name} (ID: ${property.id})`
    }));
  };

  const createFolderMutation = useMutation({
    mutationFn: async (name: string) => {
      return apiRequest('/api/folders', {
        method: 'POST',
        body: JSON.stringify({ name, path: "", section: "finance" }),
      });
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      
      // Mettre à jour le selectedFolderId
      setSelectedFolderId(data.id);
      
      // Mettre à jour la transaction actuelle avec le nouveau dossier
      const currentTransaction = transactions[currentTransactionIndex];
      updateTransactionForm(currentTransactionIndex, {
        documents: {
          files: currentTransaction.documents?.files || [],
          folderId: data.id
        }
      });
      
      setIsCreatingFolder(false);
      setNewFolderName("");
      setKey(prev => prev + 1);
      
      toast({
        title: "✨ Dossier créé",
        description: "Le dossier a été créé avec succès",
        className: "bg-gradient-to-r from-green-500/10 to-emerald-500/10 border-green-500/20",
      });
      
      console.log(`Nouveau dossier créé et associé à la transaction ${currentTransactionIndex + 1}:`, data.id);
    },
    onError: (error) => {
      toast({ title: "Erreur", description: error.message, variant: "destructive" });
    },
  });

  const handleFolderChange = (folderId: number | null) => {
    setSelectedFolderId(folderId);
    
    // Mettre à jour le dossier pour la transaction actuelle
    updateTransactionForm(currentTransactionIndex, {
      documents: {
        files: transactions[currentTransactionIndex].documents?.files || [],
        folderId
      }
    });
    
    // Log pour le débogage
    console.log(`Dossier mis à jour pour la transaction ${currentTransactionIndex + 1}:`, folderId);
  };

  const formatFoldersForSelect = (folders: any[] = []) => {
    return folders.map(folder => ({
      value: folder.id.toString(),
      label: folder.name
    }));
  };

  useEffect(() => {
    const transaction = transactions[currentTransactionIndex];
    if (transaction) {
      // Ne pas incrémenter la clé à chaque changement car cela provoque des rechargements
      // setKey(key => key + 1);
      
      // Mettre à jour le dossier sélectionné avec celui de la transaction courante
      setSelectedFolderId(transaction.documents?.folderId || null);
      
      // Mettre à jour le type pour chaque document de cette transaction
      if (transaction.documents?.files?.length) {
        const newDocTypes = new Map(documentTypes);
        transaction.documents.files.forEach(file => {
          if (!newDocTypes.has(file)) {
            newDocTypes.set(file, "invoice");
          }
        });
        setDocumentTypes(newDocTypes);
      }
      
      // Ajouter un log pour déboguer
      console.log(`Changement vers la transaction ${currentTransactionIndex + 1}`);
      console.log(`Nombre de documents: ${transaction.documents?.files?.length || 0}`);
      console.log(`Documents:`, transaction.documents?.files);
    }
  }, [currentTransactionIndex, transactions]);

  // Définir les types de documents valides selon le schéma
  const validDocumentTypes = [
    'contract', 'lease', 'invoice', 'form', 'maintenance', 
    'insurance', 'tax', 'legal', 'certificate',
    'payment', 'deposit', 'budget', 'expense',
    'tenant', 'guarantor', 'inventory', 'complaint',
    'inspection', 'repair', 'renovation', 'plan', 
    'notice', 'correspondence', 'report', 'meeting', 
    'other'
  ] as const;
  type ValidDocumentType = typeof validDocumentTypes[number];

  // Remplacer la déclaration existante et ajouter du typage
  const documentTypeConfig: DocumentTypeConfig = {
    // Types de documents existants
    "invoice": { 
      label: "Factures", 
      icon: <CreditCardIcon className="h-3 w-3 text-blue-500" />
    },
    "contract": { 
      label: "Contrat", 
      icon: <FilePenLine className="h-3 w-3 text-emerald-500" /> 
    },
    "lease": { 
      label: "Bail", 
      icon: <FileSignature className="h-3 w-3 text-amber-500" /> 
    },
    "form": { 
      label: "Formulaire", 
      icon: <Clipboard className="h-3 w-3 text-violet-500" /> 
    },
    "maintenance": { 
      label: "Entretien", 
      icon: <FileSearch className="h-3 w-3 text-red-500" /> 
    },
    "insurance": { 
      label: "Assurance", 
      icon: <FileCheck className="h-3 w-3 text-cyan-500" /> 
    },
    "tax": { 
      label: "Impôts", 
      icon: <FileIcon className="h-3 w-3 text-orange-500" /> 
    },
    "legal": { 
      label: "Juridique", 
      icon: <FileSpreadsheet className="h-3 w-3 text-gray-500" /> 
    },
    "certificate": { 
      label: "Certificat", 
      icon: <FileCheck className="h-3 w-3 text-green-500" /> 
    },
    "payment": { 
      label: "Paiement", 
      icon: <CreditCardIcon className="h-3 w-3 text-indigo-500" /> 
    },
    "deposit": { 
      label: "Dépôt", 
      icon: <Euro className="h-3 w-3 text-amber-500" /> 
    },
    "budget": { 
      label: "Budget", 
      icon: <FileSpreadsheet className="h-3 w-3 text-blue-500" /> 
    },
    "expense": { 
      label: "Dépense", 
      icon: <CreditCardIcon className="h-3 w-3 text-red-500" /> 
    },
    "tenant": { 
      label: "Locataire", 
      icon: <FileIcon className="h-3 w-3 text-purple-500" /> 
    },
    "guarantor": { 
      label: "Garant", 
      icon: <FileIcon className="h-3 w-3 text-teal-500" /> 
    },
    "inventory": { 
      label: "Inventaire", 
      icon: <FileSpreadsheet className="h-3 w-3 text-emerald-500" /> 
    },
    "complaint": { 
      label: "Réclamation", 
      icon: <Mail className="h-3 w-3 text-red-500" /> 
    },
    "inspection": { 
      label: "Inspection", 
      icon: <FileSearch className="h-3 w-3 text-amber-500" /> 
    },
    "repair": { 
      label: "Réparation", 
      icon: <FileIcon className="h-3 w-3 text-red-500" /> 
    },
    "renovation": { 
      label: "Rénovation", 
      icon: <FileIcon className="h-3 w-3 text-cyan-500" /> 
    },
    "plan": { 
      label: "Plan", 
      icon: <FileImage className="h-3 w-3 text-blue-500" /> 
    },
    "notice": { 
      label: "Avis", 
      icon: <FileIcon className="h-3 w-3 text-orange-500" /> 
    },
    "correspondence": { 
      label: "Correspondance", 
      icon: <Mail className="h-3 w-3 text-blue-500" /> 
    },
    "report": { 
      label: "Rapport", 
      icon: <FileSpreadsheet className="h-3 w-3 text-violet-500" /> 
    },
    "meeting": { 
      label: "Réunion", 
      icon: <FileIcon className="h-3 w-3 text-emerald-500" /> 
    },
    "other": { 
      label: "Autre", 
      icon: <FileIcon className="h-3 w-3 text-gray-500" /> 
    }
  };

  // Mappage des types français vers les types valides du schéma
  const typeMapping: Record<string, ValidDocumentType> = {
    "facture": "invoice",
    "contrat": "contract",
    "bail": "lease",
    "quittance": "other",
  };

  // Liste triée des types de documents pour l'affichage
  const availableDocumentTypes = Object.keys(documentTypeConfig)
    .sort((a, b) => documentTypeConfig[a].label.localeCompare(documentTypeConfig[b].label));

  // Mettre à jour le type d'un document
  const updateDocumentType = (index: number, type: string) => {
    const currentDocs = transactions[currentTransactionIndex].documents?.files || [];
    const file = currentDocs[index];
    if (file) {
      setDocumentTypes(prev => {
        const newMap = new Map(prev);
        newMap.set(file, type);
        return newMap;
      });
    }
  };

  // Fonction pour vérifier l'existence des fichiers si documents?.files est undefined
  const hasDocs = (index: number): boolean => {
    const docs = transactions[index]?.documents;
    return !!docs && Array.isArray(docs.files) && docs.files.length > 0;
  };

  // Fonction pour obtenir le nom sans extension pour l'édition
  const getNameWithoutExtension = (fileName: string): string => {
    return fileName.replace(/\.[^/.]+$/, "");
  };

  // Mettre à jour le nom d'un document
  const updateDocumentName = (file: File, name: string) => {
    // Vérifier si le nom se termine par .pdf, sinon l'ajouter
    const fullName = name.toLowerCase().endsWith('.pdf') ? name : `${name}.pdf`;
    
    setDocumentNames(prev => {
      const newMap = new Map(prev);
      newMap.set(file, fullName);
      return newMap;
    });
  };

  // Ajouter cette fonction pour afficher l'indicateur de chargement des documents
  const renderDocumentsContent = () => {
    if (isLoadingDocuments) {
      return (
        <div className="flex flex-col items-center justify-center p-6 space-y-4 border border-dashed rounded-md bg-background/30">
          <Loader2 className="h-8 w-8 text-blue-500 animate-spin" />
          <p className="text-sm text-muted-foreground">Chargement des documents existants...</p>
        </div>
      );
    }
    
    return (
      <>
        <PDFUpload
          onFileSelected={handleFileSelected}
          multiple
          key={`upload-${currentTransactionIndex}-${transactions[currentTransactionIndex]?.documents?.files?.length || 0}-${key}`}
          initialFiles={transactions[currentTransactionIndex]?.documents?.files || []}
          maxFiles={10}
        />
        
        {hasDocs(currentTransactionIndex) && (
          <div className="grid gap-2 mt-3 border rounded-md p-3 bg-background/30">
            <h4 className="text-sm font-medium mb-1">Types de documents</h4>
            {transactions[currentTransactionIndex]?.documents?.files?.map((file, index) => (
              <motion.div
                key={index}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.3, delay: index * 0.05 }}
                className="flex items-center justify-between p-2 bg-background/70 rounded-md border border-border/50"
              >
                <div className="flex items-center gap-2 flex-1">
                  <FileTextIcon className="h-4 w-4 text-blue-500" />
                  {/* Indiquer que c'est un document existant si c'est le cas */}
                  {('documentId' in file) && (
                    <div className="px-1.5 py-0.5 bg-blue-500/10 text-blue-500 text-xs rounded-full">
                      Existant
                    </div>
                  )}
                  {editingDocumentName === file ? (
                    <div className="relative flex-1 max-w-[230px]">
                      <Input
                        className="h-7 text-xs py-1 px-2 w-full pr-8"
                        defaultValue={getNameWithoutExtension(documentNames.get(file) || file.name)}
                        placeholder="Nouveau nom de fichier"
                        autoFocus
                        onBlur={(e) => {
                          if (e.target.value.trim()) {
                            updateDocumentName(file, e.target.value);
                          }
                          setEditingDocumentName(null);
                        }}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            if (e.currentTarget.value.trim()) {
                              updateDocumentName(file, e.currentTarget.value);
                            }
                            setEditingDocumentName(null);
                          } else if (e.key === 'Escape') {
                            setEditingDocumentName(null);
                          }
                        }}
                      />
                      <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-xs text-muted-foreground">.pdf</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-1">
                      <span className="text-sm truncate">{documentNames.get(file) || file.name}</span>
                      <Button 
                        type="button"
                        variant="ghost" 
                        size="sm"
                        onClick={() => setEditingDocumentName(file)}
                        className="h-6 w-6 p-0 hover:bg-blue-500/10 hover:text-blue-500"
                        title="Renommer le fichier"
                      >
                        <PencilIcon className="h-3 w-3" />
                      </Button>
                    </div>
                  )}
                </div>
                
                <div className="flex items-center gap-2">
                  <Select 
                    value={documentTypes.get(file) || "invoice"}
                    onValueChange={(value) => updateDocumentType(index, value)}
                  >
                    <SelectTrigger className="w-[150px] h-8 text-xs bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors">
                      <SelectValue placeholder="Type de document" />
                    </SelectTrigger>
                    <SelectContent 
                      className="bg-background/80 backdrop-blur-sm border-blue-500/20" 
                      sideOffset={5}
                      position="popper"
                      align="start"
                    >
                      <div 
                        className="document-type-dropdown py-1 px-1"
                        onWheel={(e) => {
                          // Empêcher la propagation de l'événement de la molette
                          e.stopPropagation();
                        }}
                      >
                        {/* Option par défaut: Facture */}
                        <SelectItem key="invoice" value="invoice" className="text-xs hover:bg-blue-500/10 cursor-pointer">
                          <div className="flex items-center gap-2">
                            {documentTypeConfig["invoice"].icon}
                            <span className="font-medium">{documentTypeConfig["invoice"].label}</span>
                          </div>
                        </SelectItem>
                        
                        <SelectSeparator className="my-1" />
                        
                        {/* Documents principaux */}
                        <SelectGroup>
                          <SelectLabel className="text-xs font-semibold text-blue-500/80 pl-2 pointer-events-none">Documents principaux</SelectLabel>
                          {["contract", "lease", "form", "maintenance"].map((type) => (
                            <SelectItem key={type} value={type} className="text-xs hover:bg-blue-500/10 cursor-pointer">
                              <div className="flex items-center gap-2">
                                {documentTypeConfig[type as keyof DocumentTypeConfig].icon}
                                <span>{documentTypeConfig[type as keyof DocumentTypeConfig].label}</span>
                              </div>
                            </SelectItem>
                          ))}
                        </SelectGroup>
                        
                        {/* Les autres groupes de documents restent inchangés */}
                      </div>
                    </SelectContent>
                  </Select>
                  
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      const currentDocs = transactions[currentTransactionIndex].documents?.files || [];
                      const newFiles = currentDocs.filter((_, i) => i !== index);
                      
                      // Mettre à jour les types de documents
                      const fileToRemove = currentDocs[index];
                      if (fileToRemove) {
                        setDocumentTypes(prev => {
                          const newMap = new Map(prev);
                          newMap.delete(fileToRemove);
                          return newMap;
                        });
                        
                        setDocumentNames(prev => {
                          const newMap = new Map(prev);
                          newMap.delete(fileToRemove);
                          return newMap;
                        });
                      }
                      
                      // Conserver le dossier sélectionné actuel
                      const currentFolderId = transactions[currentTransactionIndex].documents?.folderId || selectedFolderId;
                      
                      // Mettre à jour la transaction
                      updateTransactionForm(currentTransactionIndex, {
                        documents: {
                          files: newFiles,
                          folderId: currentFolderId
                        }
                      });
                      
                      // Si c'était le dernier document, forcer le rechargement du composant PDFUpload
                      if (newFiles.length === 0) {
                        setKey(prev => prev + 1);
                      }
                    }}
                    className="h-8 w-8 p-0 hover:bg-red-500/10 hover:text-red-500"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              </motion.div>
            ))}
          </div>
        )}
      </>
    );
  };

  return (
    <>
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent className="max-w-2xl max-h-[90vh] p-0 gap-0 bg-gradient-to-br from-background via-background/80 to-blue-500/10 border-blue-500/20 overflow-y-auto">
          <div className="p-6 space-y-6">
            <DialogHeader>
              <DialogTitle className="text-xl font-semibold bg-gradient-to-r from-blue-500 to-cyan-500 bg-clip-text text-transparent flex items-center gap-2">
                {editingTransaction ? (
                  <>
                    <FileTextIcon className="h-6 w-6 text-blue-500" />
                    Modifier la transaction
                  </>
                ) : (
                  <>
                    <FileTextIcon className="h-6 w-6 text-blue-500" />
                    Nouvelle transaction
                  </>
                )}
              </DialogTitle>
              <DialogDescription className="text-base text-muted-foreground/80">
                {editingTransaction
                  ? "Modifiez les informations de la transaction existante"
                  : "Ajoutez une ou plusieurs transactions"}
              </DialogDescription>
            </DialogHeader>

            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.5 }}
              className="space-y-4"
            >
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-muted-foreground">
                    Transaction {currentTransactionIndex + 1} sur {transactions.length}
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  {transactions.length > 1 && (
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => removeTransaction(currentTransactionIndex)}
                      className="bg-red-500/10 hover:bg-red-500/20 text-red-500 border-red-500/20"
                    >
                      <X className="h-4 w-4 mr-2" />
                      Supprimer
                    </Button>
                  )}
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={addNewTransaction}
                    className="bg-blue-500/10 hover:bg-blue-500/20 text-blue-500 border-blue-500/20"
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Ajouter une transaction
                  </Button>
                </div>
              </div>

              <div className="relative">
                <div className="absolute inset-y-0 left-0 flex items-center z-10">
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => setCurrentTransactionIndex(prev => Math.max(0, prev - 1))}
                    disabled={currentTransactionIndex === 0}
                    className="h-6 w-6 rounded-full bg-background/80 backdrop-blur-sm hover:bg-blue-500/10 border border-border/50 shadow-lg"
                  >
                    <ChevronLeft className="h-3 w-3" />
                  </Button>
                </div>

                <div className="flex items-center justify-center gap-1 px-8">
                  {(() => {
                    const startIndex = Math.max(0, Math.min(
                      currentTransactionIndex - 3,
                      transactions.length - 8
                    ));
                    return transactions.slice(startIndex, startIndex + 8).map((_, index) => {
                      const actualIndex = startIndex + index;
                      const isActive = currentTransactionIndex === actualIndex;
                      return (
                        <motion.div
                          key={actualIndex}
                          initial={{ scale: 0.95, opacity: 0 }}
                          animate={{ scale: 1, opacity: 1 }}
                          transition={{ duration: 0.2 }}
                          className="relative"
                        >
                          <Button
                            type="button"
                            variant={isActive ? "default" : "outline"}
                            size="sm"
                            onClick={() => setCurrentTransactionIndex(actualIndex)}
                            className={`
                              min-w-[60px] h-6 px-1.5 relative overflow-hidden text-xs
                              ${isActive 
                                ? "bg-gradient-to-r from-blue-500 to-cyan-500 text-white hover:from-blue-600 hover:to-cyan-600 shadow-lg" 
                                : "bg-background/50 hover:bg-blue-500/10 border-border/50"
                              }
                            `}
                          >
                            <div className="flex items-center justify-center gap-1">
                              <FileTextIcon className={`h-3 w-3 ${isActive ? "text-white" : "text-blue-500"}`} />
                              <span>#{actualIndex + 1}</span>
                            </div>
                            {isActive && (
                              <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-cyan-500/20 animate-pulse" />
                            )}
                          </Button>
                        </motion.div>
                      );
                    });
                  })()}
                </div>

                <div className="absolute inset-y-0 right-0 flex items-center z-10">
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => setCurrentTransactionIndex(prev => Math.min(transactions.length - 1, prev + 1))}
                    disabled={currentTransactionIndex === transactions.length - 1}
                    className="h-6 w-6 rounded-full bg-background/80 backdrop-blur-sm hover:bg-blue-500/10 border border-border/50 shadow-lg"
                  >
                    <ChevronRight className="h-3 w-3" />
                  </Button>
                </div>
              </div>

            <Form {...form} key={key}>
                <form onSubmit={(e) => {
                  e.preventDefault();
                  onSubmit();
                }} className="space-y-6">
                      <div className="grid gap-6">
                        {/* Type et Montant */}
                        <motion.div 
                          className="grid gap-6 sm:grid-cols-2"
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.3 }}
                        >
                          <FormField
                            control={form.control}
                        name="type"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Tag className="h-4 w-4 text-blue-500" />
                                  Type
                                </FormLabel>
                          <Select onValueChange={(value) => {
                            field.onChange(value);
                            onFormChange({ type: value as TransactionFormData["type"] });
                          }} defaultValue={field.value}>
                                  <FormControl>
                                    <SelectTrigger className="bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors">
                                      <SelectValue placeholder="Sélectionner un type" />
                                    </SelectTrigger>
                                  </FormControl>
                                  <SelectContent className="bg-background/80 backdrop-blur-sm border-blue-500/20">
                                    <SelectItem value="income" className="hover:bg-blue-500/5">
                                      <div className="flex items-center gap-2">
                                        <ArrowUpCircle className="h-4 w-4 text-green-500" />
                                        Revenu
                                      </div>
                                    </SelectItem>
                                    <SelectItem value="expense" className="hover:bg-blue-500/5">
                                      <div className="flex items-center gap-2">
                                        <ArrowDownCircle className="h-4 w-4 text-red-500" />
                                        Dépense
                                      </div>
                                    </SelectItem>
                                  </SelectContent>
                                </Select>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={form.control}
                        name="amount"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Euro className="h-4 w-4 text-blue-500" />
                                  Montant
                                </FormLabel>
                                <FormControl>
                                  <Input
                                    type="number"
                                    step="0.01"
                                    placeholder="0,00"
                                    {...field}
                              onChange={(e) => {
                                field.onChange(e);
                                onFormChange({ amount: Number(e.target.value) });
                              }}
                                    className="font-mono bg-background/50 border-border/50 hover:border-blue-500/50 focus:border-blue-500/50 transition-colors"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </motion.div>

                        <Separator className="bg-border/50" />

                        {/* Date et Propriété */}
                        <motion.div 
                          className="grid gap-6 sm:grid-cols-2"
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.3, delay: 0.1 }}
                        >
                          <FormField
                            control={form.control}
                        name="date"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Calendar className="h-4 w-4 text-blue-500" />
                              Date de la transaction
                                </FormLabel>
                                <FormControl>
                                  <Input
                                    type="date"
                                    {...field}
                              onChange={(e) => {
                                field.onChange(e);
                                onFormChange({ date: e.target.value });
                              }}
                                    className="bg-background/50 border-border/50 hover:border-blue-500/50 focus:border-blue-500/50 transition-colors"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={form.control}
                        name="propertyId"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Building2 className="h-4 w-4 text-blue-500" />
                                  Propriété
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <HelpCircle className="h-4 w-4 text-muted-foreground cursor-help" />
                                  </TooltipTrigger>
                                  <TooltipContent>
                                    <p>Associez cette transaction à une propriété spécifique (optionnel)</p>
                                  </TooltipContent>
                                </Tooltip>
                              </TooltipProvider>
                                </FormLabel>
                                <FormControl>
                                  <Combobox
                                    options={[
                                  { value: "null", label: "Aucune propriété" },
                                      ...formatPropertiesForSelect(Array.isArray(properties) ? properties : [])
                                    ]}
                                value={field.value?.toString() || "null"}
                              onValueChange={(value) => {
                                field.onChange(value === "null" ? null : parseInt(value));
                                onFormChange({ propertyId: value === "null" ? null : parseInt(value) });
                              }}
                                    placeholder="Sélectionner une propriété"
                                    emptyText="Aucune propriété trouvée"
                                    searchPlaceholder="Rechercher une propriété..."
                                    className="bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </motion.div>

                        <Separator className="bg-border/50" />

                        {/* Catégorie et Description */}
                        <motion.div 
                          className="grid gap-6 sm:grid-cols-2"
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.3, delay: 0.2 }}
                        >
                          <FormField
                            control={form.control}
                        name="category"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Tag className="h-4 w-4 text-blue-500" />
                                  Catégorie
                                </FormLabel>
                          <Select onValueChange={(value) => {
                            field.onChange(value);
                            onFormChange({ category: value as TransactionFormData["category"] });
                          }} defaultValue={field.value}>
                                  <FormControl>
                                    <SelectTrigger className="bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors">
                                      <SelectValue placeholder="Sélectionner une catégorie" />
                                    </SelectTrigger>
                                  </FormControl>
                                  <SelectContent className="bg-background/80 backdrop-blur-sm border-blue-500/20">
                                    <SelectItem value="rent" className="hover:bg-blue-500/5">Loyer</SelectItem>
                                    <SelectItem value="maintenance" className="hover:bg-blue-500/5">Maintenance</SelectItem>
                                    <SelectItem value="utility" className="hover:bg-blue-500/5">Charges</SelectItem>
                                    <SelectItem value="insurance" className="hover:bg-blue-500/5">Assurance</SelectItem>
                                    <SelectItem value="tax" className="hover:bg-blue-500/5">Taxe</SelectItem>
                                    <SelectItem value="other" className="hover:bg-blue-500/5">Autre</SelectItem>
                                  </SelectContent>
                                </Select>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={form.control}
                        name="description"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <FileTextIcon className="h-4 w-4 text-blue-500" />
                                  Description
                                </FormLabel>
                                <FormControl>
                                  <Input
                                    {...field}
                                    value={field.value || ''}
                                    placeholder="Description de la transaction"
                              onChange={(e) => {
                                field.onChange(e);
                                onFormChange({ description: e.target.value });
                              }}
                                    className="bg-background/50 border-border/50 hover:border-blue-500/50 focus:border-blue-500/50 transition-colors"
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </motion.div>

                        <Separator className="bg-border/50" />

                        {/* Méthode de paiement et Statut */}
                        <motion.div 
                          className="grid gap-6 sm:grid-cols-2"
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ duration: 0.3, delay: 0.3 }}
                        >
                          <FormField
                            control={form.control}
                        name="paymentMethod"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                              <CreditCardIcon className="h-4 w-4 text-blue-500" />
                                  Méthode de paiement
                                </FormLabel>
                          <Select onValueChange={(value) => {
                            field.onChange(value);
                            onFormChange({ paymentMethod: value as TransactionFormData["paymentMethod"] });
                          }} defaultValue={field.value}>
                                  <FormControl>
                                    <SelectTrigger className="bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors">
                                      <SelectValue placeholder="Sélectionner une méthode" />
                                    </SelectTrigger>
                                  </FormControl>
                                  <SelectContent className="bg-background/80 backdrop-blur-sm border-blue-500/20">
                                    <SelectItem value="cash" className="hover:bg-blue-500/5">Espèces</SelectItem>
                                    <SelectItem value="bank_transfer" className="hover:bg-blue-500/5">Virement bancaire</SelectItem>
                                    <SelectItem value="check" className="hover:bg-blue-500/5">Chèque</SelectItem>
                                    <SelectItem value="card" className="hover:bg-blue-500/5">Carte bancaire</SelectItem>
                                    <SelectItem value="stripe" className="hover:bg-blue-500/5">Stripe</SelectItem>
                                    <SelectItem value="paypal" className="hover:bg-blue-500/5">PayPal</SelectItem>
                                    <SelectItem value="sepa" className="hover:bg-blue-500/5">SEPA</SelectItem>
                                  </SelectContent>
                                </Select>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={form.control}
                        name="status"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="flex items-center gap-2">
                                  <Clock className="h-4 w-4 text-blue-500" />
                                  Statut
                                </FormLabel>
                          <Select onValueChange={(value) => {
                            field.onChange(value);
                            onFormChange({ status: value as TransactionFormData["status"] });
                          }} defaultValue={field.value}>
                                  <FormControl>
                                    <SelectTrigger className="bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors">
                                      <SelectValue placeholder="Sélectionner un statut" />
                                    </SelectTrigger>
                                  </FormControl>
                                  <SelectContent className="bg-background/80 backdrop-blur-sm border-blue-500/20">
                                    <SelectItem value="pending" className="hover:bg-blue-500/5">En attente</SelectItem>
                                    <SelectItem value="completed" className="hover:bg-blue-500/5">Complété</SelectItem>
                                    <SelectItem value="cancelled" className="hover:bg-blue-500/5">Annulé</SelectItem>
                                  </SelectContent>
                                </Select>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </motion.div>

                  {/* Section Documents */}
                        <motion.div
                      className="space-y-4"
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3, delay: 0.3 }}
                  >
                    <div className="flex items-center justify-between">
                      <h3 className="text-lg font-medium flex items-center gap-2">
                        <FileTextIcon className="h-5 w-5 text-blue-500" />
                        Documents
                      </h3>
                    </div>

                    <div className="grid gap-4">
                      <div className="space-y-2">
                        <Label>Dossier de destination</Label>
                              <div className="flex items-center gap-2">
                          {!isCreatingFolder ? (
                            <>
                              <Combobox
                                options={[
                                  { value: "", label: "Aucun dossier" },
                                  ...formatFoldersForSelect(Array.isArray(folders) ? folders : [])
                                ]}
                                value={selectedFolderId?.toString() || ""}
                                onValueChange={(value) => handleFolderChange(value ? parseInt(value) : null)}
                                placeholder="Aucun dossier"
                                emptyText="Aucun dossier trouvé"
                                searchPlaceholder="Rechercher un dossier..."
                                className="w-full bg-background/50 border-border/50 hover:bg-blue-500/5 hover:border-blue-500/50 transition-colors"
                              />
                              <Button
                                type="button"
                                variant="outline"
                                size="sm"
                                onClick={() => setIsCreatingFolder(true)}
                                className="border-blue-500/20 hover:bg-blue-500/10 min-w-[100px]"
                              >
                                <PlusCircle className="h-4 w-4 mr-2" />
                                Créer
                              </Button>
                            </>
                          ) : (
                            <>
                            <Input
                              placeholder="Nom du nouveau dossier"
                              value={newFolderName}
                              onChange={(e) => setNewFolderName(e.target.value)}
                                className="flex-1 bg-background/50 hover:bg-background/80 transition-colors"
                                onKeyDown={(e) => {
                                  if (e.key === 'Enter' && newFolderName.trim()) {
                                    createFolderMutation.mutate(newFolderName.trim());
                                  } else if (e.key === 'Escape') {
                                    setIsCreatingFolder(false);
                                    setNewFolderName("");
                                  }
                                }}
                            />
                                <Button
                                  type="button"
                                  variant="outline"
                                  size="sm"
                              onClick={() => {
                                if (newFolderName.trim()) {
                                  createFolderMutation.mutate(newFolderName.trim());
                                }
                              }}
                                disabled={!newFolderName.trim() || createFolderMutation.isPending}
                                className="border-blue-500/20 hover:bg-blue-500/10"
                            >
                              {createFolderMutation.isPending ? (
                                <Loader2 className="h-4 w-4 animate-spin" />
                              ) : (
                                  "Valider"
                              )}
                            </Button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setIsCreatingFolder(false);
                                setNewFolderName("");
                              }}
                                className="hover:bg-blue-500/10"
                            >
                              Annuler
                                </Button>
                            </>
                        )}
                      </div>
                      </div>

                      {renderDocumentsContent()}
                    </div>
                  </motion.div>

                  {/* Bouton de confirmation */}
                <motion.div
                  className="flex justify-center w-full pt-8 pb-4 mt-4"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.3, delay: 0.4 }}
                >
                  <Button
                    type="submit"
                    className="w-full h-12 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-medium text-base rounded-md flex justify-center items-center gap-2"
                    disabled={createTransaction.isPending || updateTransaction.isPending}
                  >
                    {createTransaction.isPending || updateTransaction.isPending ? (
                      <div className="flex items-center gap-3">
                        <Loader2 className="h-5 w-5 animate-spin" />
                        <span>Traitement en cours...</span>
                      </div>
                    ) : (
                      <div className="flex items-center gap-3">
                        <Plus className="h-5 w-5" />
                        <span>Confirmer la transaction</span>
                      </div>
                    )}
                  </Button>
                </motion.div>
              </form>
            </Form>
          </motion.div>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}